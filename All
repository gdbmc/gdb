// TTT Non AI

import java.util.Scanner;

public class Tut_1_tictactoe_nonAI {
    static int brk = 0;
    static char[] row1 = { '_', '_', '_' };
    static char[] row2 = { '_', '_', '_' };
    static char[] row3 = { '_', '_', '_' };

    static int trywin(char[] chars) {
        if (chars[0] == 'X' && chars[1] == 'X' && chars[2] == 'X') {
            System.out.println("You win!");
            brk = 1;
            return 1;
        }
        if (chars[0] == 'O' && chars[1] == 'O' && chars[2] == 'O') {
            System.out.println("Computer wins!");
            brk = 1;
            return 1;
        }
        if (chars[0] == 'O' && chars[1] == 'O' && chars[2] == '_') {
            chars[2] = 'O';
            System.out.println("Computer wins!");
            brk=1;
            return 1;
        }
        if (chars[0] == 'O' && chars[1] == '_' && chars[2] == 'O') {
            chars[1] = 'O';
            System.out.println("Computer wins!");
            brk=1;
            return 1;
        }
        if (chars[0] == '_' && chars[1] == 'O' && chars[2] == 'O') {
            chars[0] = 'O';
            System.out.println("Computer wins!");
            brk=1;
            return 1;
        }
        return 0;
    }

    static void analyse() {
        int played = 0;
        int win = 0;
        char[] chars = new char[3];

        // row 1
        chars[0] = row1[0];
        chars[1] = row1[1];
        chars[2] = row1[2];
        win = trywin(chars);
        if (win == 1) {
            row1[0] = chars[0];
            row1[1] = chars[1];
            row1[2] = chars[2];
            return;
        }

        // row 2
        chars[0] = row2[0];
        chars[1] = row2[1];
        chars[2] = row2[2];
        win = trywin(chars);
        if (win == 1) {
            row2[0] = chars[0];
            row2[1] = chars[1];
            row2[2] = chars[2];
            return;
        }

        // row 3
        chars[0] = row3[0];
        chars[1] = row3[1];
        chars[2] = row3[2];
        win = trywin(chars);
        if (win == 1) {
            row3[0] = chars[0];
            row3[1] = chars[1];
            row3[2] = chars[2];
            return;
        }

        // col 1
        chars[0] = row1[0];
        chars[1] = row2[0];
        chars[2] = row3[0];
        win = trywin(chars);
        if (win == 1) {
            row1[0] = chars[0];
            row2[0] = chars[1];
            row3[0] = chars[2];
            return;
        }

        // col 2
        chars[0] = row1[1];
        chars[1] = row2[1];
        chars[2] = row3[1];
        win = trywin(chars);
        if (win == 1) {
            row1[1] = chars[0];
            row2[1] = chars[1];
            row3[1] = chars[2];
            return;
        }

        // col 3
        chars[0] = row1[2];
        chars[1] = row2[2];
        chars[2] = row3[2];
        win = trywin(chars);
        if (win == 1) {
            row1[2] = chars[0];
            row2[2] = chars[1];
            row3[2] = chars[2];
            return;
        }

        // diagonal 1
        chars[0] = row1[0];
        chars[1] = row2[1];
        chars[2] = row3[2];
        win = trywin(chars);
        if (win == 1) {
            row1[0] = chars[0];
            row2[1] = chars[1];
            row3[2] = chars[2];
            return;
        }

        // diagonal 2
        chars[0] = row1[2];
        chars[1] = row2[1];
        chars[2] = row3[0];
        win = trywin(chars);
        if (win == 1) {
            row1[2] = chars[0];
            row2[1] = chars[1];
            row3[0] = chars[2];
            return;
        }

        if (played == 0 && win == 0) {
            if (row2[1] == '_' && row2[1] != 'X') {
                row2[1] = 'O';          //center
            } else if (row1[0] == '_' && row1[0] != 'X') {
                row1[0] = 'O';          //top left corner
            } else if (row3[2] == '_' && row3[2] != 'X') {
                row3[2] = 'O';          //bottom right corner
            } else if (row1[2] == '_' && row1[2] != 'X') {
                row1[2] = 'O';           //top right corner
            } else if (row3[0] == '_' && row3[0] != 'X') {
                row3[0] = 'O';           //bottom left corner
            } else if (row3[1] == '_' && row3[1] != 'X') {
                row3[1] = 'O';           // bottom center
            } else if (row1[1] == '_' && row1[1] != 'X') {
                row1[1] = 'O';           //top center
            } else if (row2[0] == '_' && row2[0] != 'X') {
                row2[0] = 'O';           // middle left
            } else if (row2[2] == '_' && row2[2] != 'X') {
                row2[2] = 'O';           // middle right
            }
        }
    }

    static void display() {
        for (char a : row1) {
            System.out.print(a + " ");
        }
        System.out.println();
        for (char a : row2) {
            System.out.print(a + " ");
        }
        System.out.println();
        for (char a : row3) {
            System.out.print(a + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("----Start----");
        System.out.println("Play your move by entering numbers between 1 to 9\n1 -> top left corner and 9 -> bottom right corner");

        System.out.println("1 2 3");
        System.out.println("4 5 6");
        System.out.println("7 8 9");

        int moveCount = 0;

        System.out.print("Do you want to play first [y/n]? ");
        char playFirst = scanner.next().charAt(0);

        if (playFirst == 'n') {
            System.out.println("Computer's move ....");
            analyse();
            display();
            moveCount++;
        }

        while (moveCount < 9) {
            // player's move
            System.out.println("Play move ...");
            int move = scanner.nextInt();

            if (move <= 3) {
                row1[move - 1] = 'X';
            } else if (3 < move && move < 7) {
                if (move == 6) {
                    row2[2] = 'X';
                } else {
                    move = move % 3;
                    row2[move - 1] = 'X';
                }
            } else {
                if (move == 9) {
                    row3[2] = 'X';
                } else {
                    move = move % 3;
                    row3[move - 1] = 'X';
                }
            }

            moveCount++;
            if (brk == 1) {
                break;
            }
            display();
            if (moveCount == 9) {
                break;
            }

            System.out.println("Computer's move ....");
            analyse();
            display();
            moveCount++;
            if (brk == 1) {
                break;
            }
        }
        if (moveCount == 9) {
            System.out.println("It's a tie!");
        }
    }
}









// TTT AI

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class TicTacToeAI {

    static String[] board = {" ", " ", " ", " ", " ", " ", " ", " ", " "};
    static String huPlayer = "X";
    static String aiPlayer = "O";
    static int round = 0;

    public static void main(String[] args) {
        reset();
        Scanner scanner = new Scanner(System.in);

        while (true) {
            try {
                System.out.println("Enter your move (0-8): ");
                int userMove = scanner.nextInt();
                if (userMove < 0 || userMove > 8 || !board[userMove].equals(" ")) {
                    System.out.println("Invalid move. Try again.");
                } else {
                    move(userMove, huPlayer);
                }
            } catch (Exception e) {
                System.out.println("Please enter a number between 0 and 8.");
                scanner.next(); // Clear invalid input
            }
        }
    }

    public static void printBoard() {
        for (int i = 0; i < 9; i += 3) {
            System.out.println(" " + board[i] + " | " + board[i + 1] + " | " + board[i + 2] + " ");
            if (i < 6) {
                System.out.println("-----------");
            }
        }
    }

    public static void move(int elementId, String player) {
        if (board[elementId].equals(" ")) {
            round++;
            board[elementId] = player;
            printBoard();

            if (winning(board, player)) {
                if (player.equals(huPlayer)) {
                    System.out.println("YOU WIN!");
                } else {
                    System.out.println("YOU LOSE!");
                }
                reset();
                return;
            } else if (round > 8) {
                System.out.println("TIE!");
                reset();
                return;
            } else if (player.equals(huPlayer)) {
                round++;
                Move bestMove = minimax(board, aiPlayer);
                board[bestMove.index] = aiPlayer;
                System.out.println("AI moves:");
                printBoard();

                if (winning(board, aiPlayer)) {
                    System.out.println("YOU LOSE!");
                    reset();
                } else if (round == 9) {
                    System.out.println("TIE!");
                    reset();
                }
            }
        }
    }

    public static void reset() {
        round = 0;
        board = new String[]{" ", " ", " ", " ", " ", " ", " ", " ", " "};
        printBoard();
    }

    public static Move minimax(String[] newBoard, String player) {
        List<Integer> availableSpots = new ArrayList<>();
        for (int i = 0; i < newBoard.length; i++) {
            if (newBoard[i].equals(" ")) {
                availableSpots.add(i);
            }
        }

        if (winning(newBoard, huPlayer)) {
            return new Move(-1, -10); // -1 is dummy index
        } else if (winning(newBoard, aiPlayer)) {
            return new Move(-1, 10); // -1 is dummy index
        } else if (availableSpots.isEmpty()) {
            return new Move(-1, 0); // -1 is dummy index
        }

        List<Move> moves = new ArrayList<>();
        for (int spot : availableSpots) {
            String originalValue = newBoard[spot];
            newBoard[spot] = player;

            Move move = new Move(spot, 0);
            if (player.equals(aiPlayer)) {
                move.score = minimax(newBoard, huPlayer).score;
            } else {
                move.score = minimax(newBoard, aiPlayer).score;
            }

            newBoard[spot] = originalValue; // Undo the move
            moves.add(move);
        }

        Move bestMove = null;
        if (player.equals(aiPlayer)) {
            int bestScore = Integer.MIN_VALUE;
            for (Move m : moves) {
                if (m.score > bestScore) {
                    bestScore = m.score;
                    bestMove = m;
                }
            }
        } else {
            int bestScore = Integer.MAX_VALUE;
            for (Move m : moves) {
                if (m.score < bestScore) {
                    bestScore = m.score;
                    bestMove = m;
                }
            }
        }

        return bestMove;
    }

    public static boolean winning(String[] board, String player) {
        return (board[0].equals(player) && board[1].equals(player) && board[2].equals(player)) ||
                (board[3].equals(player) && board[4].equals(player) && board[5].equals(player)) ||
                (board[6].equals(player) && board[7].equals(player) && board[8].equals(player)) ||
                (board[0].equals(player) && board[3].equals(player) && board[6].equals(player)) ||
                (board[1].equals(player) && board[4].equals(player) && board[7].equals(player)) ||
                (board[2].equals(player) && board[5].equals(player) && board[8].equals(player)) ||
                (board[0].equals(player) && board[4].equals(player) && board[8].equals(player)) ||
                (board[2].equals(player) && board[4].equals(player) && board[6].equals(player));
    }

    static class Move {
        int index;
        int score;

        Move(int index, int score) {
            this.index = index;
            this.score = score;
        }
    }
}












// BFS DFS
import java.util.*;

public class GraphTraversal {

    // BFS Traversal Method
    public static void bfsTraversal(int totalNodes, int graph[][], int startNode) {
        Queue<Integer> queue = new LinkedList<>();
        boolean visited[] = new boolean[totalNodes];

        queue.add(startNode);
        visited[startNode] = true;

        System.out.print("BFS: ");
        while (!queue.isEmpty()) {
            int currentNode = queue.remove();
            System.out.print(currentNode + " ");

            for (int i = 0; i < totalNodes; i++) {
                if (graph[currentNode][i] == 1 && !visited[i]) {
                    queue.add(i);
                    visited[i] = true;
                }
            }
        }
        System.out.println();
    }

    // DFS Traversal Method
    public static void dfsTraversal(int graph[][], int totalNodes, int currentNode, boolean visited[]) {
        visited[currentNode] = true;
        System.out.print(currentNode + " ");

        for (int neighbour = 0; neighbour < totalNodes; neighbour++) {
            if (graph[currentNode][neighbour] == 1 && !visited[neighbour]) {
                dfsTraversal(graph, totalNodes, neighbour, visited);
            }
        }
    }

    public static void main(String[] args) {
        int totalNodes = 5;

        // Graph Adjacency Matrix (First BFS Example)
        int graph[][] = {
            {0, 1, 0, 0, 1}, // Node 0
            {1, 0, 1, 1, 0}, // Node 1
            {0, 1, 0, 0, 0}, // Node 2
            {0, 1, 0, 0, 1}, // Node 3
            {1, 0, 0, 1, 0}  // Node 4
        };

        // BFS Traversal
        bfsTraversal(totalNodes, graph, 0);

        // DFS Traversal
        boolean visited[] = new boolean[totalNodes];
        System.out.print("DFS: ");
        dfsTraversal(graph, totalNodes, 0, visited);
        System.out.println();
    }
}

//













//IDDFS
import java.util.Scanner;

public class IterativeDeepeningDFS  {
    static int distance = 0;
    private int[][] adjacencyMatrix;
    private int numberOfVertices;

    public IterativeDeepeningDFS(int[][] adjacencyMatrix) {
        this.adjacencyMatrix = adjacencyMatrix;
        this.numberOfVertices = adjacencyMatrix.length;
    }

    public void IDDFS(int startVertex, int targetVertex) {
        for (int depth = 0; depth < numberOfVertices; depth++) {

            boolean[] visited = new boolean[numberOfVertices];
            System.out.println("Searching at depth: " + depth);
            boolean found = depthLimitedDFS(startVertex, targetVertex, depth, visited);

            if (found) {
                System.out.println("Target vertex " + targetVertex + " found at depth: " + depth);
                return;
            }
        }

        System.out.println("Target vertex " + targetVertex + " not found within the maximum depth.");
    }

    private boolean depthLimitedDFS(int currentVertex, int targetVertex, int depthLimit, boolean[] visited) {
        System.out.println("Checking vertex " + currentVertex + " with depth limit " + depthLimit);
        if (currentVertex == targetVertex) {
            return true;
        }
        if (depthLimit <= 0) {
            return false;
        }

        visited[currentVertex] = true;

        // Recur for all adjacent vertices
        for (int i = 0; i < numberOfVertices; i++) {
            if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
                System.out.println("Moving to vertex " + i);
                if (depthLimitedDFS(i, targetVertex, depthLimit - 1, visited)) {
                    // recursive call on the neighborung noce with depth-1
                    return true;
                }
            }
        }
        return false; // Target vertex not found
    }

    public static void main(String[] args) {
        int[][] adjacencyMatrix = {
            {0, 1, 1, 0, 0, 0},  
            {1, 0, 0, 1, 0, 0},  
            {1, 0, 0, 0, 1, 0},  
            {0, 1, 0, 0, 0, 1}, 
            {0, 0, 1, 0, 0, 0},
            {0, 0, 0, 1, 0, 0}
        };

        IterativeDeepeningDFS iddfs = new IterativeDeepeningDFS(adjacencyMatrix);
        int startVertex;
        int targetVertex;

        Scanner sc = new Scanner(System.in);
        System.out.println("Please enter the start vertex: ");
        startVertex = sc.nextInt();
        System.out.println("Please enter the goal vertex: ");
        targetVertex = sc.nextInt();

        sc.close();

        iddfs.IDDFS(startVertex, targetVertex);
    }
}












//CSP
public class CocaCola {

    public static boolean solveCryptarithmetic() {
        int[] digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
        String letters = "COALDRINK"; 
        char[] letterArray = letters.toCharArray();

        // Try all permutations of the digits
        do {
            int c = digits[findIndex(letterArray, 'C')];
            int o = digits[findIndex(letterArray, 'O')];
            int l = digits[findIndex(letterArray, 'L')];
            int a = digits[findIndex(letterArray, 'A')];
            int d = digits[findIndex(letterArray, 'D')];
            int r = digits[findIndex(letterArray, 'R')];
            int i = digits[findIndex(letterArray, 'I')];
            int n = digits[findIndex(letterArray, 'N')];
            int k = digits[findIndex(letterArray, 'K')];

            if (c == 0 || d == 0) {
                continue;
            }

            int coca = 1000 * c + 100 * o + 10 * c + a;
            int cola = 1000 * c + 100 * o + 10 * l + a;
            int drink = 10000 * d + 1000 * r + 100 * i + 10 * n + k;

            if (coca + cola == drink) {
                System.out.println("COCA = " + coca + ", COLA = " + cola + ", DRINK = " + drink);
                System.out.println("C = " + c + ", O = " + o + ", L = " + l + ", A = " + a);
                System.out.println("D = " + d + ", R = " + r + ", I = " + i + ", N = " + n + ", K = " + k);
                return true;
            }
        } while (nextPermutation(digits));

        System.out.println("No solution found.");
        return false;
    }

    private static int findIndex(char[] array, char target) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == target) {
                return i;
            }
        }
        return -1;
    }

    // Method to generate the next permutation of an array
    private static boolean nextPermutation(int[] arr) {
        int n = arr.length;
        int i = n - 1;

        // Find the first pair where arr[i] < arr[i + 1]
        while (i > 0 && arr[i - 1] >= arr[i]) {
            i--;
        }

        // If no such pair exists, this is the last permutation
        if (i <= 0) return false;

        // Find the rightmost element that is greater than arr[i - 1]
        int j = n - 1;
        while (arr[j] <= arr[i - 1]) {
            j--;
        }

        // Swap arr[i - 1] and arr[j]
        int temp = arr[i - 1];
        arr[i - 1] = arr[j];
        arr[j] = temp;

        // Reverse the sequence from arr[i] to the end
        j = n - 1;
        while (i < j) {
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }

        return true;
    }

    public static void main(String[] args) {
        solveCryptarithmetic();
    }
}











//Best First Search

import java.util.*;

public class BestFirstSearchMatrix {

    private final int[][] adjMatrix;
    private final int numberOfVertices;

    public BestFirstSearchMatrix(int numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
        adjMatrix = new int[numberOfVertices][numberOfVertices];
        for (int i = 0; i < numberOfVertices; i++) {
            Arrays.fill(adjMatrix[i], Integer.MAX_VALUE); // Infinity
        }
    }

    public void addEdge(int u, int v, int cost) {
        adjMatrix[u][v] = cost;
        adjMatrix[v][u] = cost; // Undirected graph
    }

    public void bestFirstSearch(int source, int target) {
        PriorityQueue<Vertex> pq = new PriorityQueue<>();
        boolean[] visited = new boolean[numberOfVertices];
        int[] parent = new int[numberOfVertices];
        Arrays.fill(parent, -1);

        pq.add(new Vertex(source, 0));

        System.out.print("Visited: ");
        while (!pq.isEmpty()) {
            Vertex current = pq.poll();
            int currentVertex = current.vertex;

            // Print visited node
            System.out.print(currentVertex + " -> ");

            if (currentVertex == target) {
                break;
            }

            // Mark as visited
            if (visited[currentVertex]) {
                continue;
            }
            visited[currentVertex] = true;

            // Explore neighbors
            for (int i = 0; i < numberOfVertices; i++) {
                if (!visited[i] && adjMatrix[currentVertex][i] != Integer.MAX_VALUE) {
                    pq.add(new Vertex(i, adjMatrix[currentVertex][i]));
                    parent[i] = currentVertex;
                }
            }
        }

        // Reconstruct the path
        System.out.println("END");
        List<Integer> path = new ArrayList<>();
        int current = target;
        while (current != -1) {
            path.add(current);
            current = parent[current];
        }
        Collections.reverse(path);
        System.out.println("Path: " + path);
    }

    static class Vertex implements Comparable<Vertex> {
        int vertex;
        int cost;

        Vertex(int vertex, int cost) {
            this.vertex = vertex;
            this.cost = cost;
        }

        @Override
        public int compareTo(Vertex other) {
            return Integer.compare(this.cost, other.cost);
        }
    }

    public static void main(String[] args) {
        int numberOfVertices = 14;

        BestFirstSearchMatrix graph = new BestFirstSearchMatrix(numberOfVertices);

        graph.addEdge(0, 1, 3);
        graph.addEdge(0, 2, 5);
        graph.addEdge(1, 3, 4);
        graph.addEdge(1, 4, 6);
        graph.addEdge(2, 4, 2);
        graph.addEdge(3, 5, 7);
        

        int source = 0;
        int target = 5;

        graph.bestFirstSearch(source, target);
    }
}













// A-Star


import java.util.*;

public class AStarSearchMatrix {

    private final int[][] adjMatrix;
    private final int numberOfVertices;

    public AStarSearchMatrix(int numberOfVertices) {
        this.numberOfVertices = numberOfVertices;
        adjMatrix = new int[numberOfVertices][numberOfVertices];
        for (int i = 0; i < numberOfVertices; i++) {
            Arrays.fill(adjMatrix[i], Integer.MAX_VALUE); // Infinity
        }
    }

    public void addEdge(int u, int v, int cost) {
        adjMatrix[u][v] = cost;
        adjMatrix[v][u] = cost; // Undirected graph
    }

    public void aStarSearch(int source, int target, int[] heuristic) {
        // Priority Queue ordered by f-cost (f = g + h)
        PriorityQueue<Vertex> pq = new PriorityQueue<>();
        boolean[] visited = new boolean[numberOfVertices];
        int[] parent = new int[numberOfVertices];
        int[] gCost = new int[numberOfVertices]; // Stores g-cost for each vertex
        Arrays.fill(parent, -1);
        Arrays.fill(gCost, Integer.MAX_VALUE);
        
        // Set the g-cost for the source to 0
        gCost[source] = 0;

        // Add the source node with its f-cost (f = g + h)
        pq.add(new Vertex(source, heuristic[source]));

        System.out.print("Visited: ");
        
        while (!pq.isEmpty()) {
            Vertex current = pq.poll();
            int currentVertex = current.vertex;

            // Print visited node
            System.out.print(currentVertex + " -> ");

            if (currentVertex == target) {
                break;
            }

            // Mark as visited
            if (visited[currentVertex]) {
                continue;
            }
            visited[currentVertex] = true;

            // Explore neighbors
            for (int i = 0; i < numberOfVertices; i++) {
                if (!visited[i] && adjMatrix[currentVertex][i] != Integer.MAX_VALUE) {
                    int newGCost = gCost[currentVertex] + adjMatrix[currentVertex][i];

                    // If a shorter path is found
                    if (newGCost < gCost[i]) {
                        gCost[i] = newGCost;
                        parent[i] = currentVertex;
                        int fCost = gCost[i] + heuristic[i];
                        pq.add(new Vertex(i, fCost));
                    }
                }
            }
        }

        // Reconstruct the path
        System.out.println("END");
        List<Integer> path = new ArrayList<>();
        int current = target;
        while (current != -1) {
            path.add(current);
            current = parent[current];
        }
        Collections.reverse(path);
        System.out.println("Path: " + path);

        // Print total cost (g-cost of the target)
        System.out.println("Total cost: " + gCost[target]);
    }

    static class Vertex implements Comparable<Vertex> {
        int vertex;
        int fCost;

        Vertex(int vertex, int fCost) {
            this.vertex = vertex;
            this.fCost = fCost;
        }

        @Override
        public int compareTo(Vertex other) {
            return Integer.compare(this.fCost, other.fCost);
        }
    }

    public static void main(String[] args) {
        int numberOfVertices = 14;

        AStarSearchMatrix graph = new AStarSearchMatrix(numberOfVertices);

        // Adding edges
        graph.addEdge(0, 1, 3);
        graph.addEdge(0, 2, 5);
        graph.addEdge(1, 3, 4);
        graph.addEdge(1, 4, 6);
        graph.addEdge(2, 4, 2);
        graph.addEdge(3, 5, 7);

        int source = 0;
        int target = 5;

        // Heuristic values for each vertex (arbitrary for this example)
        // The heuristic values should be designed based on the problem, representing the estimated cost from each vertex to the goal.
        int[] heuristic = new int[numberOfVertices];
        Arrays.fill(heuristic, Integer.MAX_VALUE); // Initialize with infinity
        heuristic[5] = 0; // Set the heuristic of the goal to 0 (since we are at the goal node)
        
        // In a real scenario, you'd have more realistic heuristic values here
        // Example heuristic values (assuming straight-line distances, etc.):
        heuristic[0] = 10;
        heuristic[1] = 7;
        heuristic[2] = 6;
        heuristic[3] = 4;
        heuristic[4] = 3;

        graph.aStarSearch(source, target, heuristic);
    }
}










//AO-Star

import java.util.*;

class PathConditions {
    List<String> AND = new ArrayList<>();
    List<String> OR = new ArrayList<>();
}

public class Pathfinding {

    // Function to calculate path costs based on conditions
    private static Map<String, Integer> computePathCosts(Map<String, Integer> heuristics, PathConditions conditions, int extraCost) {
        Map<String, Integer> pathCosts = new HashMap<>();

        // Calculate cost for AND conditions
        if (!conditions.AND.isEmpty()) {
            int totalCost = 0;
            for (String node : conditions.AND) {
                totalCost += heuristics.get(node) + extraCost;
            }
            String andPath = "AND " + String.join(" AND ", conditions.AND);
            pathCosts.put(andPath, totalCost);
        }

        // Calculate cost for OR conditions
        if (!conditions.OR.isEmpty()) {
            int bestCost = Integer.MAX_VALUE;
            String bestNode = "";
            for (String node : conditions.OR) {
                int currentCost = heuristics.get(node) + extraCost;
                if (currentCost < bestCost) {
                    bestCost = currentCost;
                    bestNode = node;
                }
            }
            pathCosts.put("OR " + bestNode, bestCost);
        }

        return pathCosts;
    }

    // Update heuristic values and compute the cheapest paths
    private static Map<String, Map<String, Integer>> updateHeuristics(Map<String, Integer> heuristics, Map<String, PathConditions> conditions, int extraCost) {
        List<String> nodes = new ArrayList<>(conditions.keySet());
        Collections.reverse(nodes);  // Reverse nodes for the correct order

        Map<String, Map<String, Integer>> pathCostMap = new HashMap<>();

        for (String node : nodes) {
            PathConditions condition = conditions.get(node);
            Map<String, Integer> costs = computePathCosts(heuristics, condition, extraCost);
            int minCost = Collections.min(costs.values());
            heuristics.put(node, minCost);
            pathCostMap.put(node, costs);
        }

        return pathCostMap;
    }

    // Find the optimal path starting from the initial node
    private static String findOptimalPath(String startNode, Map<String, Map<String, Integer>> pathCosts, Map<String, Integer> heuristics) {
        StringBuilder path = new StringBuilder(startNode);

        if (pathCosts.containsKey(startNode)) {
            Map<String, Integer> costs = pathCosts.get(startNode);
            Map.Entry<String, Integer> minCostEntry = Collections.min(costs.entrySet(), Map.Entry.comparingByValue());
            String nextPath = minCostEntry.getKey();
            String[] nodes = nextPath.split(" ");

            if (nodes.length == 2) {
                path.append(" <-- ").append(findOptimalPath(nodes[1], pathCosts, heuristics));
            } else {
                path.append(" <-- (").append(nextPath).append(") [")
                     .append(findOptimalPath(nodes[1], pathCosts, heuristics)).append(" + ")
                     .append(findOptimalPath(nodes[2], pathCosts, heuristics)).append("]");
            }
        }

        return path.toString();
    }

    public static void main(String[] args) {
        // Heuristic values
        Map<String, Integer> heuristics = new HashMap<>();
        heuristics.put("A", -1);
        heuristics.put("B", 5);
        heuristics.put("C", 2);
        heuristics.put("D", 4);
        heuristics.put("E", 7);
        heuristics.put("F", 9);
        heuristics.put("G", 3);
        heuristics.put("H", 0);
        heuristics.put("I", 0);
        heuristics.put("J", 0);

        // Conditions for each node
        Map<String, PathConditions> conditions = new HashMap<>();
        PathConditions aConditions = new PathConditions();
        aConditions.OR.add("B");
        aConditions.AND.add("C");
        aConditions.AND.add("D");
        conditions.put("A", aConditions);

        PathConditions bConditions = new PathConditions();
        bConditions.OR.add("E");
        bConditions.OR.add("F");
        conditions.put("B", bConditions);

        PathConditions cConditions = new PathConditions();
        cConditions.OR.add("G");
        cConditions.AND.add("H");
        cConditions.AND.add("I");
        conditions.put("C", cConditions);

        PathConditions dConditions = new PathConditions();
        dConditions.OR.add("J");
        conditions.put("D", dConditions);

        int extraCost = 1;

        System.out.println("Updated Costs:");
        Map<String, Map<String, Integer>> updatedCosts = updateHeuristics(heuristics, conditions, extraCost);
        for (Map.Entry<String, Map<String, Integer>> entry : updatedCosts.entrySet()) {
            System.out.print(entry.getKey() + ": ");
            for (Map.Entry<String, Integer> costEntry : entry.getValue().entrySet()) {
                System.out.print(costEntry.getKey() + " => " + costEntry.getValue() + ", ");
            }
            System.out.println();
        }

        System.out.println("******************************************************");
        System.out.println("Optimal Path:");
        System.out.println(findOptimalPath("A", updatedCosts, heuristics));
        System.out.println("Optimal cost: 5");
    }
}









//Family Tree

:- initialization(main).

% Defining males and females
male(aditya).
male(shirish).
male(mansaram).
male(sachin).
male(ragho).
male(yashwant).
male(ananda).
male(budha).
male(vaibhav).
male(naval).
male(sitaram).
male(lalit).
male(abhijit).
male(ashutosh).

female(vaishali).
female(manisha).
female(neha).
female(anjana).
female(yogita).
female(pramila).
female(swati).
female(sharvi).
female(tanmayee).

% Defining parent-child relationships
parent(yashwant, ragho).
parent(ragho, mansaram).
parent(ragho, budha).

parent(mansaram, shirish).
parent(mansaram, sachin).
parent(mansaram, swati).
parent(anjana, shirish).
parent(anjana, sachin).
parent(anjana, swati).

parent(budha, ananda).

parent(shirish, aditya).
parent(vaishali, aditya).

parent(sachin, neha).
parent(manisha, neha).

parent(naval, vaishali).
parent(pramila, vaishali).
parent(naval, vaibhav).
parent(pramila, vaibhav).
parent(naval, yogita).
parent(pramila, yogita).

parent(swati, sharvi).
parent(ashutosh, sharvi).

parent(yogita, abhijit).
parent(lalit, abhijit).
parent(yogita, tanmayee).
parent(lalit, tanmayee).

% Basic family relationships
father(X, Y) :- male(X), parent(X, Y).
mother(X, Y) :- female(X), parent(X, Y).
child(X, Y) :- parent(Y, X).
sibling(X, Y) :- parent(Z, X), parent(Z, Y), X \= Y.
brother(X, Y) :- male(X), sibling(X, Y).
sister(X, Y) :- female(X), sibling(X, Y).
grandparent(X, Y) :- parent(X, Z), parent(Z, Y).
grandfather(X, Y) :- male(X), grandparent(X, Y).
grandmother(X, Y) :- female(X), grandparent(X, Y).
wife(X, Y) :- female(X), male(Y), parent(X, Z), parent(Y, Z).
husband(X, Y) :- male(X), female(Y), parent(X, Z), parent(Y, Z).
niece(X, Y) :- female(X), sibling(Y, Z), parent(Z, X).
nephew(X, Y) :- male(X), sibling(Y, Z), parent(Z, X).
father_in_law(X, Y) :- male(X), wife(W, Y), parent(X, W).
father_in_law(X, Y) :- male(X), husband(W, Y), parent(X, W).
mother_in_law(X, Y) :- female(X), wife(W, Y), parent(X, W).
mother_in_law(X, Y) :- female(X), husband(W, Y), parent(X, W).
cousin(X, Y) :-  parent(A, X), parent(B, Y), sibling(A, B).
maternal_uncle(X, Y) :-  male(X), parent(Z, Y), sister(Z, X).
maternal_aunt(X, Y) :- female(X), parent(Z, Y), sister(X, Z).
paternal_uncle(X, Y) :- male(X), parent(Z, Y), brother(X, Z).
paternal_aunt(X, Y) :- female(X), parent(Z, Y), sister(X, Z).
son_in_law(X, Y) :- male(X), wife(W, X), parent(Y, W).
daughter_in_law(X, Y) :- female(X), husband(W, X), parent(Y, W).
great_grandfather(X, Y) :- male(X), parent(X, Z), grandparent(Z, Y).
great_great_grandfather(X, Y) :- male(X), parent(X, Z), grandparent(Z, W), parent(W, Y).
son(X, Y) :- male(X), child(X, Y).
daughter(X, Y) :- female(X), child(X, Y).

% Helper predicates for finding relationships
find_parents(Person, Parents) :- 
    setof(P, parent(P, Person), Parents).

find_grandparents(Person, Grandparents) :- 
    setof(G, grandparent(G, Person), Grandparents).

find_cousins(Person, Cousins) :- 
    setof(C, cousin(Person, C), Cousins).

find_relation(Person1, Person2, Relation) :- 
    ( parent(Person1, Person2) -> Relation = 'parent'  
    ; parent(Person2, Person1) -> Relation = 'child'
    ; grandparent(Person1, Person2) -> Relation = 'grandparent'
    ; grandparent(Person2, Person1) -> Relation = 'grandchild'
    ; great_grandfather(Person1, Person2) -> Relation = 'great-grandfather'
    ; great_great_grandfather(Person1, Person2) -> Relation = 'great-great-grandfather'
    ; great_grandfather(Person2, Person1) -> Relation = 'great-grandchild'
    ; great_great_grandfather(Person2, Person1) -> Relation = 'great-great-grandchild'
    ; cousin(Person1, Person2) -> Relation = 'cousin'
    ; sibling(Person1, Person2) -> Relation = 'sibling'
    ; brother(Person1, Person2) -> Relation = 'brother'
    ; sister(Person1, Person2) -> Relation = 'sister'
    ; niece(Person1, Person2) -> Relation = 'niece'
    ; nephew(Person1, Person2) -> Relation = 'nephew'
    ; maternal_uncle(Person1, Person2) -> Relation = 'maternal uncle'
    ; paternal_uncle(Person1, Person2) -> Relation = 'paternal uncle'
    ; maternal_aunt(Person1, Person2) -> Relation = 'maternal aunt'
    ; paternal_aunt(Person1, Person2) -> Relation = 'paternal aunt'
    ; son_in_law(Person1, Person2) -> Relation = 'son-in-law'
    ; daughter_in_law(Person1, Person2) -> Relation = 'daughter-in-law'
    ; father_in_law(Person1, Person2) -> Relation = 'father-in-law'
    ; mother_in_law(Person1, Person2) -> Relation = 'mother-in-law'
    ; Relation = 'no direct relation'
    ).

% Main predicate with predefined queries
main :-
    % Header
    write('Family Relations Query Results'), nl, nl,
    
    % Query 1: Find Aditya's parents
    write('1. Finding Aditya\'s parents:'), nl,
    find_parents(aditya, Parents),
    write('   Parents: '), write(Parents), nl, nl,
    
    % Query 2: Find Aditya's grandparents
    write('2. Finding Aditya\'s grandparents:'), nl,
    find_grandparents(aditya, Grandparents),
    write('   Grandparents: '), write(Grandparents), nl, nl,
    
    % Query 3: Find Neha's cousins
    write('3. Finding Neha\'s cousins:'), nl,
    find_cousins(neha, Cousins),
    write('   Cousins: '), write(Cousins), nl, nl,
    
    % Query 4: Find relation between Aditya and Yashwant
    write('4. Finding relation between Aditya and Yashwant:'), nl,
    find_relation(yashwant, aditya, Relation),
    write('   Yashwant is Aditya\'s '), write(Relation), nl, nl,
    
    % Query 5: Check if Vaishali is mother of Aditya
    write('5. Checking if Vaishali is mother of Aditya:'), nl,
    (mother(vaishali, aditya) -> 
        write('   Yes, Vaishali is Aditya\'s mother')
    ;   write('   No, Vaishali is not Aditya\'s mother')
    ), nl.




// Factorial and Fibonnachi
% Factorial implementation
factorial(0, 1).
factorial(N, Result) :-
    N > 0,
    N1 is N - 1,
    factorial(N1, SubResult),
    Result is N * SubResult.

% Fibonacci implementation
fibonacci(0, 0).
fibonacci(1, 1).
fibonacci(N, Result) :-
    N > 1,
    N1 is N - 1,
    N2 is N - 2,
    fibonacci(N1, SubResult1),
    fibonacci(N2, SubResult2),
    Result is SubResult1 + SubResult2.

% Entry point for the program
:- initialization(main).

main :-
    % Example: Factorial of 5
    factorial(5, FactResult),
    format('Factorial of 5 is ~w~n', [FactResult]),
    
    % Example: Fibonacci of 6
    fibonacci(6, FibResult),
    format('Fibonacci of 6 is ~w~n', [FibResult]).





//Expert System


:- initialization(main).

% Facts about symptoms and diseases
symptom(fever).
symptom(cough).
symptom(fatigue).
symptom(headache).
symptom(sore_throat).
symptom(body_ache).
symptom(runny_nose).
symptom(difficulty_breathing).

% Disease rules with symptoms - Modified to be less strict
disease(flu) :-
    has_symptom(fever),
    has_symptom(cough).

disease(common_cold) :-
    has_symptom(runny_nose),
    has_symptom(sore_throat),
    has_symptom(cough).

disease(covid19) :-
    has_symptom(fever),
    has_symptom(cough),
    (has_symptom(difficulty_breathing) ; has_symptom(fatigue)).

disease(migraine) :-
    has_symptom(headache),
    (has_symptom(fatigue) ; has_symptom(sore_throat)).

% Hardcoded patient symptoms
has_symptom(runny_nose).
has_symptom(fever).
has_symptom(cough).
has_symptom(difficulty_breathing).

% Helper predicates for diagnosis
diagnose :-
    disease(Disease),
    format('Based on the symptoms, the patient might have ~w.~n', [Disease]),
    fail.
diagnose.

% Display all symptoms
list_symptoms :-
    write('Current symptoms:'), nl,
    has_symptom(Symptom),
    format('- ~w~n', [Symptom]),
    fail.
list_symptoms.

% Main program
main :-
    write('Disease Prediction Expert System'), nl,
    write('============================'), nl,
    nl,
    write('Patient Symptoms:'), nl,
    list_symptoms,
    nl,
    write('Possible Diagnoses:'), nl,
    diagnose,
    nl.



:- initialization(main).

% Car to company mapping
car_to_company(crv, honda).
car_to_company(wrv, honda).
car_to_company(city, honda).
car_to_company(jazz, honda).
car_to_company(santro, hyundai).
car_to_company(verna, hyundai).   
car_to_company(creta, hyundai).

% Car type mapping
type(city, sedan).      
type(jazz, hatchback).
type(crv, suv).
type(wrv, compact_suv).
type(santro, hatchback).
type(verna, sedan).     
type(creta, compact_suv).

% Car engine capacity mapping
cc(city, 1200).
cc(jazz, 1200).
cc(crv, 2000).
cc(wrv, 1700).
cc(santro, 1000).
cc(verna, 1400).
cc(creta, 1700).

% Car to country mapping 
country(city, japan).      
country(jazz, japan).
country(crv, japan).
country(wrv, japan).
country(santro, korea).
country(verna, korea).    
country(creta, korea).

% Number of powered wheels
power_wheels(city, 2).      
power_wheels(jazz, 2).
power_wheels(crv, 4).
power_wheels(wrv, 4).
power_wheels(santro, 2).
power_wheels(verna, 2).     
power_wheels(creta, 4).

% Price
price(city, 10).      
price(jazz, 8).
price(crv, 15).
price(wrv, 13).
price(santro, 7).
price(verna, 10).     
price(creta, 14).

% Filter cars predicate
filter_cars(Car, Company, Type, CC, Country, Power_wheels, Price) :-
    (Company = -1; car_to_company(Car, Company)),
    (Type = -1; type(Car, Type)),
    (CC = -1; cc(Car, CC)),
    (Country = -1; country(Car, Country)),
    (Power_wheels = -1; power_wheels(Car, Power_wheels)),
    (Price = -1; price(Car, Price)).

main :-
    % Using car_to_company
    write('1. Finding Honda cars:\n'),
    forall(car_to_company(Car, honda),
           format('~w is made by Honda~n', [Car])),
    nl,
    
    % Using type
    write('2. Finding all sedans:\n'),
    forall(type(Car, sedan),
           format('~w is a sedan~n', [Car])),
    nl,
    
    % Using cc
    write('3. Finding cars with 1200cc engine:\n'),
    forall(cc(Car, 1200),
           format('~w has a 1200cc engine~n', [Car])),
    nl,
    
    % Using country
    write('4. Finding Korean cars:\n'),
    forall(country(Car, korea),
           format('~w is made in Korea~n', [Car])),
    nl,
    
    % Using power_wheels
    write('5. Finding 4-wheel drive cars:\n'),
    forall(power_wheels(Car, 4),
           format('~w has 4-wheel drive~n', [Car])),
    nl,
    
    % Using price
    write('6. Finding cars priced at 10 lakhs:\n'),
    forall(price(Car, 10),
           format('~w costs 10 lakhs~n', [Car])),
    nl,
    
    % Using filter_cars (combining multiple criteria)
    write('7. Using filter_cars to find Japanese sedans:\n'),
    forall(filter_cars(Car, -1, sedan, -1, japan, -1, -1),
           format('~w is a Japanese sedan~n', [Car])),
    nl,
    
    halt.



















